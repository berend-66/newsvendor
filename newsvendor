#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
newsvendor.py

Purpose:
    Working on newsvendor project 
    
Version:
    1 First start
    Date: 14/06/2020
Author:
    Berend
    
""" 

###########################################################
### Imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import scipy.stats as st

###########################################################
### mS= Sales(vX, vY)
def Sales(vX, vY):
    """
    Purpose:
        Find sales mS for supply vX and demand vY

    Inputs:
        vX      iX vector, supply
        vY      iY vector, demand

    Return value:
        mS      iX x iY matrix, sales
    """
    vX= np.asarray(vX).reshape(-1, 1)     # Force X to a COLUMN vector
    vY= np.asarray(vY).reshape(1, -1)     # Force Y to a ROW vector
    mS= np.minimum(vX, vY)

    return mS

###########################################################

### mPr= Profit(vX, mS, dP, dC)
def Profit(vX, mS, dP, dC):
    """
    Purpose:
        Find profit for supply vX with sales mS

    Inputs:
        vX      iX vector, supply
        mS      iX x iY matrix, sales
        dP      double, sales price
        dC      double, cost

    Return value:
        mPr     iX x iY matrix, profit
    """
    vX= np.asarray(vX).reshape(-1, 1)     # Force X to a COLUMN vector
    mPr= dP*mS - dC*vX

    return mPr

########################################################### 

### (vEPr, vEPr2)= MomProfit(vXi, dP, dC, dLambda, dF) 
def MomProfit(vX, dP, dC, dLambda, dF= 5.0):
    """
    Purpose:
        Find the first two moments of profit for supply vX, with demand
        coming from a Poisson density with parameter dLambda

    Inputs:
        vX      iX vector, supply
        dP      double, sales price
        dC      double, cost
        dLambda double, Poisson parameter, expectation of demand
        dF      (optional, default= 5.0) double, factor to use in deciding on range of y

    Return value:
        vEPr    iX vector, expected profit
        vEPr2   iX vector, expected squared profit
    """
    vY= np.arange(0, dF*dLambda)                   # Get some overly large range of demands Y
    vProbPi= st.poisson.pmf(vY, dLambda)
    
    mS= Sales(vX, vY)
    mPr= Profit(vX, mS, dP, dC)
    mPr2= (mPr**2)                        # Get squared profits as well
    
    # Get the first two moments
    vEPr=  mPr @ vProbPi                
    vEPr2= mPr2  @ vProbPi  # is this not the same as vEpr**2, it seems like it is 

    return (vEPr, vEPr2)

###########################################################

### vU= Utility(vX, dP, dC, dLambda, dGamma, dF= 5.0)
def Utility(vX, dP, dC, dLambda, dGamma, dF= 5.0):
    """
    Purpose:
        Find the utility for supply vX, with demand
        coming from a Poisson density with parameter dLambda

    Inputs:
        vX      iX vector, supply
        dP      double, sales price
        dC      double, cost
        dLambda double, Poisson parameter, expectation of demand
        dGamma  double, risk aversion
        dF      (optional, default= 5.0) double, factor to use in deciding on range of y

    Return value:
        vU      iX vector, utility
    """
    (vEPr, vEPr2)= MomProfit(vX, dP, dC, dLambda, dF)
    vVarPr= vEPr2 - vEPr**2
    vU= vEPr - dGamma * vVarPr

    return vU

###########################################################
### graph= createGraphs(vXi, iXPi, iXu, vVarPr)
def createProfitRiskUtilityGraphs(vXi, iXPi, iXu, vVarPr, vEPr, vU):
    plt.figure()
    plt.subplot(1,3,1)          # first graph
    plt.title('Profit vs order size')
    plt.ylabel('Profit')
    plt.xlabel('Order size')
    plt.axvline(x=vXi[iXPi], color='r')
    plt.plot(vXi, vEPr)         
    
    plt.subplot(1,3,2)          # second graph
    plt.title('Risk vs order size')
    plt.ylabel('Variance')
    plt.xlabel('Order size')
    plt.plot(vXi, vVarPr)
    
    plt.subplot(1,3,3)          # third graph
    plt.title('Utility vs order size')
    plt.ylabel('Utility')
    plt.xlabel('Order size')
    plt.axvline(x=vXi[iXu], color='r')
    plt.plot(vXi, vU)
    
    plt.subplots_adjust(left=0.125, right=1.3, wspace=0.5)
    plt.show()
    
    ##### add legends to each graph 

    

###########################################################
### computeProfitRiskUtility(vXi, dP, dC, dLambda, dF, dGamma)
def computeProfitRiskUtility(vXi, vEPr, vEPr2, dGamma):
    vVarPr= vEPr2 - vEPr**2
    vU= vEPr - dGamma*vVarPr
    
    iXPi= np.argmax(vEPr)       # find location of optimal profit for a supply which s for x=134
    iXu= np.argmax(vU)      # find location of optimal utility for a supply which is for x=103
    
    print('The optimal profit is generated at a supply of xPi=', vXi[iXPi])
    print('The optimal utility is generated at a supply of xU=', vXi[iXu])
    
    createProfitRiskUtilityGraphs(vXi, iXPi, iXu, vVarPr, vEPr, vU)
    
    ##do I have to return something here?
    
###########################################################
### risk aversion graphs= createRiskAversionGraphs(vGamma, vXOpt, vUOpt)
def createRiskAversionGraphs(vGamma, vXOpt, vUOpt):
    plt.figure()
    plt.subplot(1,2,1)  
    plt.plot(vGamma, vXOpt)
    plt.subplot(1,2,2)
    plt.plot(vGamma, vUOpt)
    plt.show()

    ### add legends, titles and axes lables 
    
###########################################################
### deduce @@@@@
def deduceRiskAversion(vXi, vEPr, vEPr2):
    vGamma= np.arange(0, 5, 0.1)
    iG= vGamma.shape[0]
    iXX= vXi.shape[0]
    vVarPr= vEPr2 - vEPr**2             #you are calculating vVarPr twice, here and in the computeProfitRiskUtility function
    
    vUOpt= np.zeros_like(vGamma)
    vXOpt= np.zeros_like(vGamma)
    for g in range(iG):
        dGamma= vGamma[g]
        vU= vEPr - dGamma * vVarPr
        i= np.argmax(vU)
        vUOpt[g]= vU[i]
        vXOpt[g]= vXi[i]
        
    iX= 134    #finding optimal gamma for a certain supply, note try to make this iX= vXi[iXPi], maybe by rearranging the functions
    vI= vXOpt == iX
    print ('Optimal supply x=%i is found for gamma= ' % iX, vGamma[vI])
        
        
    createRiskAversionGraphs(vGamma, vXOpt, vUOpt)
    
###########################################################
### main
def main ():
# Magic numbers
    sIn= '/Users/deberend/Desktop/Academic Skills/nv1g50v2data.xlsx'
    dP= 3.0
    dC= 1.0
    dGamma= 3
    dF= 5
    vX= [130, 90]
    v= 0
    
# Initialisation
    vX= np.array(vX)
    df= pd.read_excel(sIn, usecols=('G8V1','G8V2')) 
    mY= df.values    # Get out the data from the dataframe
    vY= mY[:,v]     # vY is the data from village 1
    iX= vX[v]
    vXi= np.arange(80, 160)

    
# Estimation
    dMu= vY.mean()
    dS2= vY.var()
    dLambda= dMu
    (vEPr, vEPr2)= MomProfit(vXi, dP, dC, dLambda, dF) ## gives us the expected profit for certain X values and the first two moments
    
# Output
    computeProfitRiskUtility(vXi, vEPr, vEPr2, dGamma) 
    deduceRiskAversion(vXi, vEPr, vEPr2)
    
########################################################### 
### start main
if __name__ == "__main__":
    main ()

