#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
newsvendor.py

Purpose:
    Working on newsvendor project 
    
Version:
    1 First start
    Date: 14/06/2020
Author:
    Berend
    
""" 

###########################################################
### Imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import scipy.stats as st

###########################################################
### mS= Sales(vX, vY)
def Sales(vX, vY):
    """
    Purpose:
        Find sales mS for supply vX and demand vY

    Inputs:
        vX      iX vector, supply
        vY      iY vector, demand

    Return value:
        mS      iX x iY matrix, sales
    """
    vX= np.asarray(vX).reshape(-1, 1)     # Force X to a COLUMN vector
    vY= np.asarray(vY).reshape(1, -1)     # Force Y to a ROW vector
    mS= np.minimum(vX, vY)

    return mS

###########################################################

### mPr= Profit(vX, mS, dP, dC)
def Profit(vX, mS, dP, dC):
    """
    Purpose:
        Find profit for supply vX with sales mS

    Inputs:
        vX      iX vector, supply
        mS      iX x iY matrix, sales
        dP      double, sales price
        dC      double, cost

    Return value:
        mPr     iX x iY matrix, profit
    """
    vX= np.asarray(vX).reshape(-1, 1)     # Force X to a COLUMN vector
    mPr= dP*mS - dC*vX

    return mPr

########################################################### 

### (vEPr, vEPr2)= MomProfit(vXi, dP, dC, dLambda, dF) 
def MomProfit(vX, dP, dC, dLambda, dF= 5.0):
    """
    Purpose:
        Find the first two moments of profit for supply vX, with demand
        coming from a Poisson density with parameter dLambda

    Inputs:
        vX      iX vector, supply
        dP      double, sales price
        dC      double, cost
        dLambda double, Poisson parameter, expectation of demand
        dF      (optional, default= 5.0) double, factor to use in deciding on range of y

    Return value:
        vEPr    iX vector, expected profit
        vEPr2   iX vector, expected squared profit
    """
    vY= np.arange(0, dF*dLambda)                   # Get some overly large range of demands Y
    vProbPi= st.poisson.pmf(vY, dLambda)
    
    mS= Sales(vX, vY)
    mPr= Profit(vX, mS, dP, dC)
    mPr2= (mPr**2)                        # Get squared profits as well
    
    # Get the first two moments
    vEPr=  mPr @ vProbPi                
    vEPr2= mPr2  @ vProbPi  # is this not the same as vEpr**2, it seems like it is 

    return (vEPr, vEPr2)

###########################################################

### vU= Utility(vX, dP, dC, dLambda, dGamma, dF= 5.0)
def Utility(vX, dP, dC, dLambda, dGamma, dF= 5.0):
    """
    Purpose:
        Find the utility for supply vX, with demand
        coming from a Poisson density with parameter dLambda

    Inputs:
        vX      iX vector, supply
        dP      double, sales price
        dC      double, cost
        dLambda double, Poisson parameter, expectation of demand
        dGamma  double, risk aversion
        dF      (optional, default= 5.0) double, factor to use in deciding on range of y

    Return value:
        vU      iX vector, utility
    """
    (vEPr, vEPr2)= MomProfit(vX, dP, dC, dLambda, dF)
    vVarPr= vEPr2 - vEPr**2
    vU= vEPr - dGamma * vVarPr

    return vU

###########################################################
### graph= createGraphs(vXi, iXPi, iXu, vVarPr)
def createProfitRiskUtilityGraphs(vXi, iXPi, iXu, vVarPr, vEPr, vU):
    plt.figure()
    plt.subplot(1,3,1)          # first graph
    plt.title('Profit vs order size')
    plt.ylabel('Profit')
    plt.xlabel('Order size')
    plt.axvline(x=vXi[iXPi], color='r')
    plt.plot(vXi, vEPr)         
    
    plt.subplot(1,3,2)          # second graph
    plt.title('Risk vs order size')
    plt.ylabel('Variance')
    plt.xlabel('Order size')
    plt.plot(vXi, vVarPr)
    
    plt.subplot(1,3,3)          # third graph
    plt.title('Utility vs order size')
    plt.ylabel('Utility')
    plt.xlabel('Order size')
    plt.axvline(x=vXi[iXu], color='r')
    plt.plot(vXi, vU)
    
    plt.subplots_adjust(left=0.125, right=1.3, wspace=0.5)
    plt.show()
    
    ##### add legends to each graph 

    

###########################################################
### computeProfitRiskUtility(vXi, dP, dC, dLambda, dF, dGamma)
def computeProfitRiskUtility(vXi, vEPr, dGamma, vVarPr):
    vU= vEPr - dGamma*vVarPr
    
    iXPi= np.argmax(vEPr)       # find location of optimal profit for a supply which s for x=134
    iXu= np.argmax(vU)      # find location of optimal utility for a supply which is for x=103
    
    print('The optimal profit is generated at a supply of xPi=', vXi[iXPi])
    print('The optimal utility is generated at a supply of xU=%i\n' % vXi[iXu])
    
    createProfitRiskUtilityGraphs(vXi, iXPi, iXu, vVarPr, vEPr, vU)
    
    
###########################################################
### risk aversion graphs= createRiskAversionGraphs(vGamma, vXOpt, vUOpt)
def createRiskAversionGraphs(vGamma, vXOpt, vUOpt):
    plt.figure()
    plt.subplot(1,2,1)                  #graph 1
    plt.title('Order size vs gamma')
    plt.ylabel('Order size')
    plt.xlabel('Gamma')
    plt.plot(vGamma, vXOpt)
    
    plt.subplot(1,2,2)                  #graph 2 
    plt.title('Utility vs gamma')       
    plt.ylabel('Utility')
    plt.xlabel('Gamma')
    plt.plot(vGamma, vUOpt)
    
    plt.subplots_adjust(left=0.125, right=1.3, wspace=0.3)
    plt.show()

    ### add legend
    
###########################################################
### deduce @@@@@
def deduceRiskAversion(vXi, vEPr, vVarPr):
    vGamma= np.arange(0, 5, 0.1)
    iG= vGamma.shape[0]

    vUOpt= np.zeros_like(vGamma)
    vXOpt= np.zeros_like(vGamma)
    for g in range(iG):
        dGamma= vGamma[g]
        vU= vEPr - dGamma * vVarPr
        i= np.argmax(vU)
        vUOpt[g]= vU[i]
        vXOpt[g]= vXi[i]
        
    iX= 134    #finding optimal gamma for a certain supply, note: need to make this iX= vXi[iXPi], maybe by rearranging the functions
    vI= vXOpt == iX
    print ('The gamma that corresponds with optimal supply x=%i is gamma=' % iX, vGamma[vI])         # how to see more decimal numbers?
        
    # we can also still find out what the original risk aversion was for the newsvendor (check the supply in the excel file. maybe read the excel file to improve code?))  
    
    createRiskAversionGraphs(vGamma, vXOpt, vUOpt)
###########################################################
### graphs= createLoglikelihoodGraphs(vLambda, vLLg, dLambdaML, dCrit, vChi2)
def createLoglikelihoodGraphs(vX, vLambda, vLLg, dLambdaML, dCrit, vChi2):
    plt.figure()
    plt.subplot(1,2,1)                          #graph 1
    plt.title('Loglikelihood vs lambda')       
    plt.ylabel('Loglikelihood')
    plt.xlabel('Lambda')
    plt.plot(vLambda, vLLg)
    plt.axvline(dLambdaML, color='red')
    plt.subplot(1,2,2)                          #graph 2 
    plt.title('Chi squared distribution')       
    #plt.ylabel('???')
    #plt.xlabel('Just values')
    plt.plot(vX, vChi2)
    plt.axvline(dCrit, color='red')
    plt.ylim(0)
    plt.show()

    #add legends

###########################################################
### computeML= 
def computeML(dLambda, vY, dAlpha):
    dDiff= 0.2
    iNum= 1000
    vLambda= np.linspace((1-dDiff)*dLambda, (1+dDiff)*dLambda, num=iNum)
    vLLg= np.zeros(iNum)                #compute loglikelihood for all the lambdas
    for i in range(iNum):
        dLambda0= vLambda[i]
        vLLg[i]= st.poisson.logpmf(vY, dLambda0).sum()
        
    i= np.argmax(vLLg)          #computing the maximum likelihood estimate
    dLambdaML= vLambda[i]
    dLLMax= vLLg[i]
    print ("\nMax LL= %g, with lambda=%g. Original estimate lambda= %g" % (dLLMax, dLambdaML, dLambda))
    
    iDoF=1 # degrees of freedom = number of restrictions
    dCrit= st.chi2.ppf(1-dAlpha, iDoF)  # Critical value of chi2 density
    print ("Critical value chi2(%g, D.o.F=%i)= %g\n" % (1-dAlpha, iDoF, dCrit))
    vX= np.arange(0, 5, .01)
    vChi2= st.chi2.pdf(vX, iDoF)
    
    vLR= -2*(vLLg - dLLMax)
    vI= vLR <= dCrit
    vLambdaCI= vLambda[vI]
    print ("Values of lambda where the LR test statistic is not too large: ", vLambdaCI) ## how to print only the first and last value of the interval?
    
    createLoglikelihoodGraphs(vX, vLambda, vLLg, dLambdaML, dCrit, vChi2)

###########################################################
### maxmin
def computeMaxMin(vX, dP, dC, vLambdaCI, dGamma):                #how to get vLambdaCI in here efficiently?
    iL= vLambdaCI.shape[0]
    iXi= vX.shape[0]
    mU= np.zeros((iXi,iL))
    plt.figure()
    for i in range(iL):
        vU= Utility(vX, dP, dC, vLambdaCI[i], dGamma)
        mU[:,i]= vU
        plt.plot(vX, vU, color= 'grey')
        vUMin= mU.min(axis=1)  # Get minimal utility over all lambda's, so over columns
        vIMin= mU.argmin(axis=1)  # Find for what lambda this minimal utility is attained
        
        i= np.argmax(vUMin)       # Find maxmin utility index
        
        plt.plot(vX, vUMin, color= 'blue')      # Accentuate minimal utility
        plt.axvline(vX[i], color='red')         # Show maxmin utility
        plt.show()    
    
###########################################################
### main
def main ():
# Magic numbers
    sIn= '/Users/deberend/Desktop/Academic Skills/nv1g50v2data.xlsx'
    dP= 3.0
    dC= 1.0
    dGamma= 3
    dF= 5
    vX= [130, 90]
    v= 0
    dAlpha= 0.05
    
# Initialisation
    vX= np.array(vX)
    df= pd.read_excel(sIn, usecols=('G8V1','G8V2')) 
    mY= df.values    # Get out the data from the dataframe
    vY= mY[:,v]     # vY is the data from village 1
    iX= vX[v]
    vXi= np.arange(80, 160)

    
# Estimation
    dMu= vY.mean()
    dS2= vY.var()
    dLambda= dMu
    (vEPr, vEPr2)= MomProfit(vXi, dP, dC, dLambda, dF) ## gives us the expected profit for certain X values and the first two moments
    vVarPr= vEPr2 - vEPr**2 
    
# Output
    computeProfitRiskUtility(vXi, vEPr, dGamma, vVarPr) 
    deduceRiskAversion(vXi, vEPr, vVarPr)
    computeML(dLambda, vY, dAlpha)
    #computeMaxMin(......)
    
########################################################### 
### start main
if __name__ == "__main__":
    main ()


